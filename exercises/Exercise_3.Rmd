---
title: "Exercise 3"
output: learnr::tutorial
runtime: shiny_prerendered
---

```{r setup, include=FALSE}
list.of.packages <- c("learnr","shiny","tidyverse","remotes")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

library(learnr)
require(tidyverse)

require(remotes)
if(!("gradethis" %in% installed.packages())){remotes::install_github("rstudio/gradethis")}
require(gradethis)

knitr::opts_chunk$set(echo = FALSE)

gradethis::gradethis_setup()
```

## Introduction

This is the third of the weekly exercises. These exercises are designed to reinforce content taught each week. Typically, they consist of quiz questions and R exercises that require you to enter code into a box. These exercises are split into beginner and advance sections. It is expected that students can complete the beginner sections of each weekly exercise, with the advanced sections designed for students who want an extra challenge or learn additional functions in R.If you are struggling, each exercise comes with a number of hints that may be helpful.

## Basic Exercises

### Question 1

In the code below, an object named `countries` is a character vector. Using the `==` operator and the `sum()` function, determine how many of the countries is "Scotland". Save the number as an object called `Scotland_N`.

```{r question_1-setup}
countries <- c("Scotland","England","France","Wales","Scotland","Australia","Scotland","England","United States","Iceland","Scotland","Spain","Scotland","Swaziland","Scotland","Switzerland","Scotland","England","France","Wales","Scotland","Australia","Scotland","England","United States","Iceland","Scotland","Spain","Scotland","Swaziland","Scotland","Switzerland")
```

```{r question_1, exercise=TRUE,exercise.lines = 5}
#countries
```

```{r question_1-hint-1}
Using a logical operator like `==` returns a logical vector. Logical vectors are a special type of Factor class that at times can be treated as numeric, with FALSE = 0 and TRUE = 1.
```

```{r question_1-hint-2}
When using the `==` operator, the two parts have to be an exact match. If there are any spelling mistakes, typos, or differences in capitalisation, the operator will return a `FALSE` value.

Next hint will show the solution...
```

```{r question_1-solution}
Scotland_N <- sum(countries == "Scotland")

#The above could be written in one line of code like this:
#temp <- countries == "Scotland"
#Scotland_N <- sum(temp)

```

```{r question_1-code-check}
grade_code()
```

### Question 2

In the code below, an object named `numbers` is a numeric vector. How many of the numbers are less than 53? Save the answer as an object called `less_than_53`.

```{r question_2-setup}
numbers <- c(71,66,64,80,19,96,33,60,61,20,37,14,74,45,70,52,43,93,53,42,36,91,82,22,9,26,95,21,75,16,52,7,36,90,45,59,60,54,95,35,38,97,49,71,38,70,6,96,85,43,45,99,51,78,49,72,44,96,62,74,62,85,17,22,89,23,98,5,80,37,17,40,75,48,3,76,88,71,80,46,88,13,34,58,94,24,28,27,68,63,17,97,23,95,37,80,2,40,36,8)
```

```{r question_2, exercise=TRUE,exercise.lines = 5}
#numbers

```

```{r question_2-hint-1}
Which operator tests for a "less than" relationship?
```

```{r question_2-hint-2}
Using a logical operator returns a logical vector. Logical vectors are a special type of Factor class that at times can be treated as numeric, with FALSE = 0 and TRUE = 1. You can use the `sum()` function to add all the `TRUE` responses.

Next hint will show the solution...
```

```{r question_2-solution}
less_than_53 <- sum(numbers < 53)
```

```{r question_2-code-check}
grade_code()
```

### Question 3

In the code below, an object named `numbers` is a data.frame. One of the variables in the data.frame is called "remove". Filter out all participants that have a value of "Exclude" for this variable and save the result as `numbers_filtered`.

```{r,echo = FALSE}
numbers <- data.frame(ID = 1:100,
                      remove = c('Include','Exclude','Exclude','Exclude','Exclude','Exclude','Include','Include','Include','Include','Include','Include','Include','Include','Exclude','Include','Exclude','Exclude','Include','Include','Include','Include','Exclude','Include','Exclude','Exclude','Include','Include','Exclude','Exclude','Include','Include','Include','Exclude','Include','Include','Exclude','Include','Include','Exclude','Include','Exclude','Include','Include','Exclude','Exclude','Exclude','Exclude','Exclude','Include','Include','Include','Include','Exclude','Exclude','Exclude','Include','Include','Exclude','Exclude','Include','Exclude','Exclude','Include','Include','Include','Exclude','Include','Exclude','Include','Include','Include','Exclude','Include','Exclude','Include','Include','Exclude','Exclude','Include','Include','Include','Include','Include','Include','Exclude','Include','Include','Exclude','Include','Exclude','Exclude','Include','Include','Exclude','Exclude','Exclude','Exclude','Include','Exclude'),
                      var1 = c(71,66,64,80,19,96,33,60,61,20,37,14,74,45,70,52,43,93,53,42,36,91,82,22,9,26,95,21,75,16,52,7,36,90,45,59,60,54,95,35,38,97,49,71,38,70,6,96,85,43,45,99,51,78,49,72,44,96,62,74,62,85,17,22,89,23,98,5,80,37,17,40,75,48,3,76,88,71,80,46,88,13,34,58,94,24,28,27,68,63,17,97,23,95,37,80,2,40,36,8))
```
```{r}
numbers
```

```{r question_3-setup}
numbers <- data.frame(ID = 1:100,
                      remove = c('Include','Exclude','Exclude','Exclude','Exclude','Exclude','Include','Include','Include','Include','Include','Include','Include','Include','Exclude','Include','Exclude','Exclude','Include','Include','Include','Include','Exclude','Include','Exclude','Exclude','Include','Include','Exclude','Exclude','Include','Include','Include','Exclude','Include','Include','Exclude','Include','Include','Exclude','Include','Exclude','Include','Include','Exclude','Exclude','Exclude','Exclude','Exclude','Include','Include','Include','Include','Exclude','Exclude','Exclude','Include','Include','Exclude','Exclude','Include','Exclude','Exclude','Include','Include','Include','Exclude','Include','Exclude','Include','Include','Include','Exclude','Include','Exclude','Include','Include','Exclude','Exclude','Include','Include','Include','Include','Include','Include','Exclude','Include','Include','Exclude','Include','Exclude','Exclude','Include','Include','Exclude','Exclude','Exclude','Exclude','Include','Exclude'),
                      var1 = c(71,66,64,80,19,96,33,60,61,20,37,14,74,45,70,52,43,93,53,42,36,91,82,22,9,26,95,21,75,16,52,7,36,90,45,59,60,54,95,35,38,97,49,71,38,70,6,96,85,43,45,99,51,78,49,72,44,96,62,74,62,85,17,22,89,23,98,5,80,37,17,40,75,48,3,76,88,71,80,46,88,13,34,58,94,24,28,27,68,63,17,97,23,95,37,80,2,40,36,8))
```

```{r question_3, exercise=TRUE,exercise.lines = 5}
#numbers

```

```{r question_3-hint-1}
Use the `filter()` function to remove participants.
```

```{r question_3-hint-2}
You want to exclude participants with a certain value for the variable named 'remove'. Use the != operator to determine which participants do not have this value.

Next hint will show the solution...
```

```{r question_3-solution}
numbers_filtered <- filter(numbers,remove != "Exclude")

#OR you could use the following logically equivalent code:

#numbers_filtered <- filter(numbers,remove == "Include")
```

```{r question_3-code-check}
grade_code()
```

### Question 4

In the code below, there is a data.frame called `personality`, where six participants were measured on the Big-5 personality dimensions (openness, conscientiousness, extraversion, agreeableness, and neuroticism). However, you are only interested in the conscientiousness and neuroticism dimensions. Use a tidyverse function to create a dataset with only the ID, conscientiousness, and neuroticism variables and save the result as `personality_cleaned`.

```{r,echo = FALSE}
personality <- data.frame(ID = 1:6,
                      openness = c(3,5,1,4,2,3),
                      conscientiousness = c(1,4,2,3,3,2),
                      extraversion = c(3,5,4,2,2,3),
                      agreeableness = c(1,3,2,2,5,3),
                      neuroticism = c(3,3,4,2,1,5))
```
```{r}
personality
```

```{r question_4-setup}
personality <- data.frame(ID = 1:6,
                      openness = c(3,5,1,4,2,3),
                      conscientiousness = c(1,4,2,3,3,2),
                      extraversion = c(3,5,4,2,2,3),
                      agreeableness = c(1,3,2,2,5,3),
                      neuroticism = c(3,3,4,2,1,5))
```

```{r question_4, exercise=TRUE,exercise.lines = 5}
#personality

```

```{r question_4-hint-1}
Which tidyverse function can you use to select the variables you are interested in?
```

```{r question_4-hint-2}
Remember, we are after a data.frame with three variables: "ID", "conscientiousness", and "neuroticism".

Next hint will show the solution...
```

```{r question_4-solution}
personality_cleaned <- select(personality,ID,conscientiousness,neuroticism)
```

```{r question_4-code-check}
grade_code()
```

### Question 5

You have conducted a study measuring how many minutes participants engage in physical exercise each day. You have measured 6 participants every day for a week - this data is saved below as `phys_exer`. You wish to analyse the total number of minutes participants spent exercising during the week. Use a tidyverse function to create a new data.frame called `phys_exer_total` with a new variable called `total` which is the sum of minutes across the seven days.

```{r,echo = FALSE}
phys_exer <- data.frame(ID = 1:6,
                      sunday = c(0,15,10,40,0,30),
                      monday = c(10,40,20,30,0,20),
                      tuesday = c(30,15,40,20,0,30),
                      wednesday = c(10,30,20,20,0,30),
                      thursday = c(30,30,40,20,10,15),
                      friday = c(5,60,30,10,10,0),
                      saturday = c(120,0,10,20,10,0))
```
```{r}
phys_exer
```

```{r question_5-setup}
phys_exer <- data.frame(ID = 1:6,
                      sunday = c(0,15,10,40,0,30),
                      monday = c(10,40,20,30,0,20),
                      tuesday = c(30,15,40,20,0,30),
                      wednesday = c(10,30,20,20,0,30),
                      thursday = c(30,30,40,20,10,15),
                      friday = c(5,60,30,10,10,0),
                      saturday = c(120,0,10,20,10,0))
```

```{r question_5, exercise=TRUE,exercise.lines = 5}
#phys_exer

```

```{r question_5-hint-1}
Which tidyverse function can you use to mutate the variables to create a new variable?
```

```{r question_5-hint-2}
Remember, we are after a data.frame with a new variable called "total" that the amount of minutes of the seven days added together.

Next hint will show the solution...
```

```{r question_5-solution}
phys_exer_total <- mutate(phys_exer,total = sunday + monday + tuesday + wednesday + thursday + friday + saturday)

#Note: the days of the week could be in any order, but the checker for this question will expect the order above.
```

```{r question_5-code-check}
grade_code()
```

### Question 6

After showing your supervisor your work from Question 5, they flippantly remark that perhaps you should analyse the mean number of minutes participants exercise per day, rather than the total number of minutes across the week. Edit the code below so that the variable `total` is the mean and not the sum.

```{r question_6-setup}
phys_exer <- data.frame(ID = 1:6,
                      sunday = c(0,15,10,40,0,30),
                      monday = c(10,40,20,30,0,20),
                      tuesday = c(30,15,40,20,0,30),
                      wednesday = c(10,30,20,20,0,30),
                      thursday = c(30,30,40,20,10,15),
                      friday = c(5,60,30,10,10,0),
                      saturday = c(120,0,10,20,10,0))
```

```{r question_6, exercise=TRUE,exercise.lines = 5}
#phys_exer

phys_exer_total <- mutate(phys_exer,total = sunday + monday + tuesday + wednesday + thursday + friday + saturday)

```

```{r question_6-hint-1}
The mean (also called the average) can be calculated by adding up all the values and dividing the total by the number of values.
```

```{r question_6-hint-2}
Sometimes you need to use brackets to tell R what to divide across...

Next hint will show the solution...
```

```{r question_6-solution}
#The total score is divided by 7 to produce the average.

phys_exer_total <- mutate(phys_exer,total = (sunday + monday + tuesday + wednesday + thursday + friday + saturday)/7)
```

```{r question_6-code-check}
grade_code()
```

### Question 7

In the code below, the data.frame `dat` is being prepared for data analysis. Re-write the code to include pipes (%>%) and avoid saving intermediate data.frames. Save the final result under `data_final`.

```{r,echo = FALSE}
dat <- data.frame(ID = 1:6,
                      var1 = c(10,NA,130,440,50,360),
                      var2 = c(170,480,290,NA,10,220),
                      var3 = c(330,145,NA,260,70,380),
                      var4 = c(190,310,220,230,40,350),
                      var5 = c(360,NA,NA,290,110,125),
                      var6 = c(35,640,350,160,170,NA),
                      var7 = c(1290,10,120,230,NA,50))
```
```{r}
dat
```
```{r question_7-setup}
dat <- data.frame(ID = 1:6,
                      var1 = c(10,NA,130,440,50,360),
                      var2 = c(170,480,290,NA,10,220),
                      var3 = c(330,145,NA,260,70,380),
                      var4 = c(190,310,220,230,40,350),
                      var5 = c(360,NA,NA,290,110,125),
                      var6 = c(35,640,350,160,170,NA),
                      var7 = c(1290,10,120,230,NA,50))
```

```{r question_7, exercise=TRUE,exercise.lines = 8}
#dat
data_select.variables <- select(dat,ID,var3,var5)
data_remove.missing1 <- filter(data_select.variables,!is.na(var3))
data_remove.missing2 <- filter(data_remove.missing1,!is.na(var5))
data_final <- mutate(data_remove.missing2,total = var3 + var5)
```

```{r question_7-hint-1}
Pipes (%>%) pass the output from one command and enter it as the first argument of the next command. By using pipes, you can avoid saving intermediate datasets.
```

```{r question_7-hint-2}
Pipes can be unintuitive at first. If you're having difficulty understanding how to use pipes, try Googling "How to use pipes in R".

Next hint will show the solution...
```

```{r question_7-solution}
#dat
data_final <- select(dat,ID,var3,var5) %>%
  filter(!is.na(var3)) %>%
  filter(!is.na(var5)) %>%
  mutate(total = var3 + var5)
```

```{r question_7-code-check}
grade_code()
```

### Question 8

In the code below, the data.frame `brightside` is being prepared for data analysis. However, the code is not running correctly. There are three errors in the code below. Fix the errors so the code runs properly.

```{r question_8-setup}
brightside <- data.frame(line = c(1,2,NA,3,4),
                      word1 = c("coming","and","you","gotta","because"),
                      band = c("brandon","dave",NA,"mark","ronnie"),
                      word2 = c("out","I've","sit","gotta","I"),
                      word3 = c("of","been","there","be","want"),
                      word4 = c("my","doing","in","down","it"),
                      word5 = c("cage","just","your",NA,"all"),
                      word6 = c(NA,"fine","heartache",NA,NA))
```

```{r question_8, exercise=TRUE,exercise.lines = 8}
brightside_final <- brightside %>%
  filter(brightside,!is.na(line) %>%
  select(line word1, word2, word3, word4, word5, word6)

brightside_final
```

```{r question_8-hint-1}
If you pass an object to a function using a pipe, you do not specify the first argument.
```

```{r question_8-hint-2}
Common errors in code are missing things, such as brackets and commas...

Next hint will show the solution...
```

```{r question_8-solution}
brightside_final <- brightside %>%
  filter(!is.na(line)) %>%
  select(line, word1, word2, word3, word4, word5, word6)

brightside_final

#the first argument is not needed for the `filter()` function.
#there is a missing bracket for the `filter()` function.
#there is a missing comma for the `select()` function.
```

```{r question_8-code-check}
grade_code()
```

### Question 9

You are interested in how older adults are susceptible to scammers. You have conducted a study with 40 participants, where participants receive a susceptibility score (a number between 1 and 7) to 12 stimuli. This data is saved as the object `sus.scores`. However, after collecting the data, you noticed there is an issue with stimuli_10 and stimuli_11, and they needs to be excluded. Prepare the data.frame for data analysis by doing the following:

1. Remove the problematic variables.
1. Remove participants that are not 65 years or older.
1. Calculate a new variable called `total` that is the sum of the remaining `stimuli` variables.

Save the new data.frame as `sus.scores_final`. Note: the checker for this question expects you to use piping.

```{r,echo = FALSE}
sus.scores <- data.frame(ID = 1:40,
                         age = c(75,94,83,88,69,80,76,93,74,60,72,69,85,74,92,61,92,92,66,67,88,82,75,93,89,67,70,64,68,91,80,71,84,89,73,93,90,78,85,60),
                         stimuli_1 = c(1,7,6,6,6,5,3,1,4,3,6,1,6,3,3,4,5,4,5,1,5,5,3,1,7,5,6,5,5,1,2,7,2,2,4,1,2,7,5,4),
                         stimuli_2 = c(6,1,5,6,6,7,3,3,7,6,7,7,7,2,1,7,5,5,4,6,3,5,3,3,3,7,2,4,4,2,2,2,5,2,4,5,4,5,4,7),
                         stimuli_3 = c(7,5,4,2,1,1,4,3,5,5,5,4,4,4,5,1,7,5,4,1,1,1,2,4,6,5,6,2,5,4,3,5,2,6,7,1,1,5,3,7),
                         stimuli_4 = c(1,1,2,4,5,1,1,5,6,6,4,6,2,1,3,3,4,2,4,6,2,7,5,3,2,1,7,2,6,3,3,7,3,6,6,4,5,7,4,3),
                         stimuli_5 = c(3,5,3,5,7,7,2,6,6,5,4,1,5,2,4,5,5,2,6,5,5,3,6,3,6,3,3,2,5,7,1,5,7,2,4,3,5,5,4,7),
                         stimuli_6 = c(2,1,4,7,6,3,1,5,1,2,5,6,5,1,5,2,5,1,1,3,2,6,1,3,7,4,2,7,6,2,5,7,4,1,5,3,1,4,7,5),
                         stimuli_7 = c(2,7,1,3,3,5,4,4,2,3,4,3,2,1,6,4,7,2,3,5,2,2,2,1,6,3,3,3,3,2,1,4,5,3,3,2,4,1,3,7),
                         stimuli_8 = c(4,7,3,4,1,5,3,6,3,7,4,4,1,5,6,6,3,4,2,6,6,1,1,2,4,2,1,2,6,4,3,2,7,4,1,7,5,7,7,3),
                         stimuli_9 = c(6,7,3,4,4,2,3,1,3,7,5,2,3,5,6,6,4,5,4,1,4,3,5,6,3,2,7,5,1,6,1,5,5,7,7,2,1,7,6,3),
                         stimuli_10 = rep(-99,40),
                         stimuli_11 = rep(1,40),
                         stimuli_12 = c(3,7,3,7,5,2,2,4,5,7,3,1,7,6,4,7,4,7,3,4,2,7,7,2,7,4,7,2,6,3,4,7,7,6,5,4,6,7,2,2))
```
```{r}
sus.scores
```

```{r question_9-setup}
sus.scores <- data.frame(ID = 1:40,
                         age = c(75,94,83,88,69,80,76,93,74,60,72,69,85,74,92,61,92,92,66,67,88,82,75,93,89,67,70,64,68,91,80,71,84,89,73,93,90,78,85,60),
                         stimuli_1 = c(1,7,6,6,6,5,3,1,4,3,6,1,6,3,3,4,5,4,5,1,5,5,3,1,7,5,6,5,5,1,2,7,2,2,4,1,2,7,5,4),
                         stimuli_2 = c(6,1,5,6,6,7,3,3,7,6,7,7,7,2,1,7,5,5,4,6,3,5,3,3,3,7,2,4,4,2,2,2,5,2,4,5,4,5,4,7),
                         stimuli_3 = c(7,5,4,2,1,1,4,3,5,5,5,4,4,4,5,1,7,5,4,1,1,1,2,4,6,5,6,2,5,4,3,5,2,6,7,1,1,5,3,7),
                         stimuli_4 = c(1,1,2,4,5,1,1,5,6,6,4,6,2,1,3,3,4,2,4,6,2,7,5,3,2,1,7,2,6,3,3,7,3,6,6,4,5,7,4,3),
                         stimuli_5 = c(3,5,3,5,7,7,2,6,6,5,4,1,5,2,4,5,5,2,6,5,5,3,6,3,6,3,3,2,5,7,1,5,7,2,4,3,5,5,4,7),
                         stimuli_6 = c(2,1,4,7,6,3,1,5,1,2,5,6,5,1,5,2,5,1,1,3,2,6,1,3,7,4,2,7,6,2,5,7,4,1,5,3,1,4,7,5),
                         stimuli_7 = c(2,7,1,3,3,5,4,4,2,3,4,3,2,1,6,4,7,2,3,5,2,2,2,1,6,3,3,3,3,2,1,4,5,3,3,2,4,1,3,7),
                         stimuli_8 = c(4,7,3,4,1,5,3,6,3,7,4,4,1,5,6,6,3,4,2,6,6,1,1,2,4,2,1,2,6,4,3,2,7,4,1,7,5,7,7,3),
                         stimuli_9 = c(6,7,3,4,4,2,3,1,3,7,5,2,3,5,6,6,4,5,4,1,4,3,5,6,3,2,7,5,1,6,1,5,5,7,7,2,1,7,6,3),
                         stimuli_10 = rep(-99,40),
                         stimuli_11 = rep(1,40),
                         stimuli_12 = c(3,7,3,7,5,2,2,4,5,7,3,1,7,6,4,7,4,7,3,4,2,7,7,2,7,4,7,2,6,3,4,7,7,6,5,4,6,7,2,2))
```

```{r question_9, exercise=TRUE,exercise.lines = 10}
#sus.scores
```

```{r question_9-hint-1}
Have a look at the `sus.scores` data.frame so you have an idea of how it is structured.
```

```{r question_9-hint-2}
Use tidyverse functions, such as `select()`, `filter()`, and `mutate()` to achieve your objective.

Next hint will show the solution...
```

```{r question_9-solution}
sus.scores_final <- sus.scores %>%
  select(ID,age,stimuli_1,stimuli_2,stimuli_3,stimuli_4,stimuli_5,stimuli_6,stimuli_7,stimuli_8,stimuli_9,stimuli_12) %>%
  filter(age >= 65) %>%
  mutate(total = stimuli_1 + stimuli_2 + stimuli_3 + stimuli_4 + stimuli_5 + stimuli_6 + stimuli_7 + stimuli_8 + stimuli_9 + stimuli_12)

#Note: the checker for this question expects you to use piping, though the same could be achieved without using piping.
```

```{r question_9-code-check}
grade_code()
```

## Advanced Exercises

Up to now, we have covered some of the helpful `tidyverse` functions, but there are many more that are useful to data cleaning and preparing a data.frame for analysis. This week's advance exercises focuses on introducing a few more. Note that even after completing these exercises, we still wouldn't have covered every tidyverse function.

### Question A1 - arrange()

The `arrange()` function reorders the rows in your data.frame according to a columns in the data.frame. Like all tidyverse functions, the first argument is the data.frame you wish to manipulate. The second argument is the name of variable you wish to sort by.

```{r,eval = FALSE,echo = TRUE}
arranged.data <- arrange(data,variable_name)
```

If the variable is numeric, the data.frame will be sorted into ascending numerical order according to that variable. If the variable is a character, the data.frame will be sorted into alphabetical order according to that variable. If you want to reverse the order, use the `desc()` function within `arrange()`:

```{r,eval = FALSE,echo = TRUE}
arranged.data <- arrange(data,desc(variable_name))
```

In the box below is the planets data from Exercise 2. Use the `arrange()` function to sort the planets from most to least number of moons.

```{r question_a1-setup, include = FALSE}
planets_within_belt <- data.frame(planet = c("Mercury","Venus","Earth","Mars"),
                                  diameter_km = c(4878,12104,12756,6794),
                                  orbit_days = c(88,224,365.25,687),
                                  average.temp_c = c(427,480,14,-63),
                                  moons = c(0,0,1,2),stringsAsFactors = FALSE)

planets_beyond_belt <- data.frame(planet = c("Jupiter","Saturn","Uranus","Neptune"),
                                  diameter_km = c(142984,120536,51118,49532),
                                  orbit_days = c(11.86*365,29*365,84*365,1164.8*365),
                                  average.temp_c = c(-130,-130,-200,-200),
                                  moons = c(79,62,27,14),stringsAsFactors = FALSE)
all_planets <- bind_rows(planets_within_belt,planets_beyond_belt)
```

```{r question_a1, exercise=TRUE,exercise.lines = 5}
#all_planets

ordered_planets <- 
```

```{r question_a1-hint-1}
Check the column names for the data.frame to see what variable corresponds to the number of moons.
```

```{r question_a1-hint-2}
To order the data.frame in descending order, use the `desc()` function.

Next hint will show the solution...
```

```{r question_a1-solution}
ordered_planets <- arrange(all_planets,desc(moons))
```

### Question A2 - rename()

Use the `rename()` function to rename the variables in your data.frame. In the code below, we rename three variables in a data.frame:

```{r,eval = FALSE,echo = TRUE}
renamed.data <- rename(data,
                       new.variable.name1 = old.variable.name1,
                       new.variable.name2 = old.variable.name2,
                       new.variable.name3 = old.variable.name3)
```

A few things to note. First, to ease readability, we have spaced out this function across multiple lines. Second, the new name of the variable goes on the left of the `=` symbol, while the original name goes on the right. A common mistake is to mix this up!

In the box below is the planets data from above, but without informative variable names. Use the `rename()` function to fix this. The new variables should be `planet`, `diameter`, `orbit`, `temperature`, and `moons` in that order.

```{r question_a2-setup, include = FALSE}
planets_within_belt <- data.frame(planet = c("Mercury","Venus","Earth","Mars"),
                                  X1 = c(4878,12104,12756,6794),
                                  X2 = c(88,224,365.25,687),
                                  X3 = c(427,480,14,-63),
                                  X4 = c(0,0,1,2),stringsAsFactors = FALSE)

planets_beyond_belt <- data.frame(planet = c("Jupiter","Saturn","Uranus","Neptune"),
                                  X1 = c(142984,120536,51118,49532),
                                  X2 = c(11.86*365,29*365,84*365,1164.8*365),
                                  X3 = c(-130,-130,-200,-200),
                                  X4 = c(79,62,27,14),stringsAsFactors = FALSE)
all_planets <- bind_rows(planets_within_belt,planets_beyond_belt)
```

```{r question_a2, exercise=TRUE,exercise.lines = 5}
#all_planets

planets_with_colnames <- 
```

```{r question_a2-hint-1}
Make sure you put the new variable name on the left of the `=` symbol.
```

```{r question_a2-hint-2}
If you are spreading the function out over multiple lines, make sure to include a comma at the end of each line (i.e., between commands).

Next hint will show the solution...
```

```{r question_a2-solution}
planets_with_colnames <- rename(all_planets,
                      diameter = X1,
                      orbit = X2,
                      temperature = X3,
                      moons = X4)
```

### Question A3 - separate()

One of the key principles of data cleaning is that each cell of your data.frame should only have one variable. However, if importing data from different programs, this may not be the default - sometimes, a single variable will hold multiple values, like in the example below:

```{r}
imported.data <- data.frame(participant_id = c(1:6),
                            age_y_m = c("24_5","30_1","27_2","21_12","33_10","26_7"),
                            mean_sd = c("4.34 sd=1.22","5.28 sd=2.12","3.74 sd=1.58","6.10 sd=2.02","4.61 sd=1.81","3.99 sd=2.59"),stringsAsFactors = FALSE)
```

```{r,echo = TRUE}
imported.data
```

In the data.frame above, there are three columns; however, multiple values are saved in two of these columns: First, age should have separate columns for year and month, while the mean and standard deviation scores should also be separated into separate columns.

Below is the code that separates the 'age_y_m' variable into two:

```{r,echo = TRUE,eval = FALSE}
imported.data2 <- separate(imported.data,
                           col = age_y_m,
                           into = c("age_y","age_m"),
                           sep = "_")
```

Let's break down each or the arguments above. As always, the first argument is the data.frame you are performing the tidyverse function on. The 'col' argument specifies the name of the variable you wish to split (in the example above, the 'age_y_m'). The 'into' argument specifies the new variable names of your separated columns. You need to specify the correct number of columns in a character vector (in our example, the two new column names are 'age_y' and 'age_m'). The 'sep' argument specifies the character that separates your new column (in the example, the age in years and months are separated by an underscore, so we set `sep = "_"`.

In the box below, use the `separate()` function to split the `mean_sd` variable into separate columns for `mean` and `sd`.

```{r question_a3-setup, include = FALSE}
imported.data <- data.frame(participant_id = c(1:6),
                            age_y_m = c("24_5","30_1","27_2","21_12","33_10","26_7"),
                            mean_sd = c("4.34 sd=1.22","5.28 sd=2.12","3.74 sd=1.58","6.10 sd=2.02","4.61 sd=1.81","3.99 sd=2.59"),stringsAsFactors = FALSE)

imported.data2 <- separate(imported.data,col = age_y_m,into = c("age_y","age_m"),sep = "_")
```

```{r question_a3, exercise=TRUE,exercise.lines = 5}
#imported.data2

imported.data3 <- separate()
```

```{r question_a3-hint-1}
Make sure for the 'into' argument to specify the correct number of columns.
```

```{r question_a3-hint-2}
The 'sep' argument needs all characters that separate the values. In this case it is:
  " sd="

Next hint will show the solution...
```

```{r question_a3-solution}
imported.data3 <- separate(imported.data2,
                           col = mean_sd,
                           into = c("mean","sd"),
                           sep = " sd=")
#To aid readability, we have split the function across multiple lines.
```

### Question A4 - unite()

Occasionally, you will need to do the opposite of the `separate()` function, and combine multiple columns to one. This can be achieved with the `unite()` function.

The code below reverses the what we did in the last question. Note: this exact process is not something you will want to do for data cleaning, but is included here for illustrative purposes.

```{r,echo = TRUE,eval = FALSE}
imported.data3 <- separate(imported.data2,
                           col = mean_sd,
                           into = c("mean","sd"),
                           sep = " sd=")
```

```{r,echo = TRUE,eval = FALSE}
imported.data2 <- unite(imported.data3,
                       col = "age_y_m",
                       age_y,
                       age_m,
                       sep = "_")
imported.data <- unite(imported.data2,
                       col = "mean_sd",
                       mean,
                       sd,
                       sep = " sd=")

imported.data
```

Again, let's break down each argument. As always, the first argument is the data.frame. The 'col' argument is the name of the new variable once columns have been combined. After this, you simply list the column names you wish to combine. In both examples above, we are only pasting two columns together, but this function easily accommodates more than two. Finally, the 'sep' argument dictates how the two values will be separated within the one column (in the case of age, this is an underscore: "_").

You wish to conduct a meta-analysis across 6 papers. In the box below, the data.frame called `meta.analysis` has the effect size of the 6 papers; however, the direction and value of the effect size are saved in separate variables. Use the `unite()` function to combine the two columns. Then, calculate the mean of the effect size.

```{r,echo = FALSE}
meta.analysis <- data.frame(paper = 1:6,
                            direction = c("+","+","-","+","-","-"),
                            effect_size = c(.21,.43,.01,.11,.10,.09))
```
```{r}
meta.analysis
```

```{r question_a4-setup, include = FALSE}
meta.analysis <- data.frame(paper = 1:6,
                            direction = c("+","+","-","+","-","-"),
                            effect_size = c(.21,.43,.01,.11,.10,.09))
```

```{r question_a4, exercise=TRUE,exercise.lines = 8}
#meta.analysis
```

```{r question_a4-hint-1}
Set `sep = ""` if you do not want a character between the direction and the effect size value.
```

```{r question_a4-hint-2}
You can calculate the mean of a variable using the `summarise()` and `mean()` functions.

Next hint will show the solution...
```

```{r question_a4-solution}
#Note: the code below includes pipes (%>%). To review how these work, see Workbook 2.
combined.data <- unite(meta.analysis,
                       col = "effect",
                       direction,
                       effect_size,
                       sep = "") %>%
  mutate(effect = as.numeric(effect)) %>%
  summarise(mean.effect = mean(effect))

#Mean effect = .09

#In the above code, `sep = ""` means there are no characters separating the values.
#The command `as.numeric()` makes sure the variable 'effect' is a numeric variable.
```

### Question A5 - recode()

You can use the `recode()` function to recode individual values within a variable. To use this function, use it within a `mutate()` function.

In the data.frame below, we want to recode the values "Yes" and "No" in the complete variable to `TRUE` and `FALSE` respectively.

```{r}
data.to.recode <- data.frame(ID = 1:6,
                             complete = c("Yes","No","Yes","Yes","Yes","No"))
data.to.recode
```

```{r,echo = TRUE,eval = FALSE}
data.recoded <- mutate(data.to.recode,
                       complete_logical = recode(complete,
                                                 "Yes" = TRUE,
                                                 "No" = FALSE)
                       )

data.recoded
```

To review how the `mutate()` function works, see this week's workbook. The first argument for the `recode()` function is the variable you wish to recode. Afterwards, specify the old value and then the new value you wish to recode it to (separated by a `=` symbol). You need to be exhaustive with your list (i.e., all old values must have a new value). Also, regardless of the class of your variable, all old values must be contained within quotation marks.

In the box below, participants completed a three-item questionnaire measuring attitudes towards violent video games. Participants rated their agreements to statements on a 7-point scale (1 = Strongly Disagree, through to 7 = Strongly Agree). You require to add these values together, but first, Item 2 needs to be reverse-coded. Use the `recode()` function to acheive this, then calculate the total score on the questionnaire.

```{r question_a5-setup, include = FALSE}
video.games <- data.frame(ID = 1:6,
                          vvg1 = c(1,3,2,7,5,6),
                          vvg2 = c(5,4,6,2,1,3),
                          vvg3 = c(2,2,1,5,6,7))
```

```{r question_a5, exercise=TRUE,exercise.lines = 8}
#video.games
```

```{r question_a5-hint-1}
The first step is to recode the variable 'vvg2'. Use the `recode()` function to create a new variable where 'vvg2' has been reverse-coded.
```

```{r question_a5-hint-2}
Use the `mutate()` function to calcuate the total score once a reversed-coded 'vvg2' has been created.

Next hint will show the solution...
```

```{r question_a5-solution}
#Note: the code below includes pipes (%>%). To review how these work, see Workbook 2.
video.games2 <- mutate(video.games, vvg2_reversed = recode(vvg2,
                                             "1" = 7,
                                             "2" = 6,
                                             "3" = 5,
                                             "4" = 4,
                                             "5" = 3,
                                             "6" = 2,
                                             "7" = 1)) %>%
  mutate(vvg_total = vvg1 + vvg2_reversed + vvg3)
```